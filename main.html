<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon 3D Matrix Rain</title>
    <script src="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.js"></script>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            width: 100%;
            height: 100%;
            background-color: #000;
            font-family: monospace;
        }
        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
        }
        .controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 10px;
            color: #0f9;
            text-shadow: 0 0 5px #0f9, 0 0 10px #0f9;
            border: 1px solid #0f9;
            box-shadow: 0 0 10px #0f9, inset 0 0 5px #0f9;
            display: flex;
            gap: 15px;
        }
        .controls button, .controls input {
            background-color: rgba(0, 30, 0, 0.8);
            color: #0f9;
            border: 1px solid #0f9;
            border-radius: 5px;
            padding: 5px 10px;
            cursor: pointer;
            text-shadow: 0 0 3px #0f9;
            box-shadow: 0 0 5px #0f9;
            transition: all 0.3s;
        }
        .controls button:hover {
            background-color: rgba(0, 50, 0, 0.8);
            box-shadow: 0 0 10px #0f9, 0 0 15px #0f9;
        }
        .controls input[type="range"] {
            height: 5px;
            background: #043;
            appearance: none;
            outline: none;
            opacity: 0.7;
            transition: opacity 0.2s;
            width: 100px;
        }
        .controls input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 15px;
            height: 15px;
            background: #0f9;
            cursor: pointer;
            border-radius: 50%;
            box-shadow: 0 0 5px #0f9, 0 0 10px #0f9;
        }
        .control-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }
        .control-label {
            font-size: 12px;
        }
    </style>
</head>
<body class="bg-black">
    <canvas id="matrixCanvas"></canvas>
    
    <div class="controls">
        <div class="control-group">
            <span class="control-label">Depth</span>
            <input type="range" id="depthControl" min="1" max="10" value="5">
        </div>
        <div class="control-group">
            <span class="control-label">Speed</span>
            <input type="range" id="speedControl" min="1" max="20" value="5">
        </div>
        <div class="control-group">
            <span class="control-label">Density</span>
            <input type="range" id="densityControl" min="1" max="30" value="15">
        </div>
        <button id="resetBtn">Reset</button>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const canvas = document.getElementById('matrixCanvas');
            const ctx = canvas.getContext('2d');
            
            // Controls
            const depthControl = document.getElementById('depthControl');
            const speedControl = document.getElementById('speedControl');
            const densityControl = document.getElementById('densityControl');
            const resetBtn = document.getElementById('resetBtn');
            
            // Configuration
            let config = {
                depth: 5,
                speed: 5,
                density: 15
            };
            
            // Matrix characters
            const matrixChars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789$&%#+?><アイウエオカキクケコサシスセソタチツテトナニヌネノハヒフヘホマミムメモヤユヨラリルレロワヲン';
            
            let drops = [];
            let particles = [];
            let width, height;

            // Initialize canvas size
            function resizeCanvas() {
                width = window.innerWidth;
                height = window.innerHeight;
                canvas.width = width;
                canvas.height = height;
                initDrops();
            }
            
            // Initialize rain drops
            function initDrops() {
                drops = [];
                const columns = Math.floor(width / 20);
                
                for (let i = 0; i < columns * config.density / 10; i++) {
                    drops.push({
                        x: Math.random() * width,
                        y: Math.random() * height * -1,
                        z: Math.random() * (config.depth * 2) + 1,
                        speed: Math.random() * 2 + 1,
                        length: Math.floor(Math.random() * 15) + 5,
                        characters: []
                    });
                    
                    // Generate characters for this drop
                    for (let j = 0; j < drops[i].length; j++) {
                        drops[i].characters.push({
                            char: matrixChars.charAt(Math.floor(Math.random() * matrixChars.length)),
                            opacity: Math.random() * 0.5 + 0.5,
                            changeTime: Math.floor(Math.random() * 30) + 10
                        });
                    }
                }
            }
            
            function createParticle(x, y, z) {
                particles.push({
                    x: x,
                    y: y,
                    z: z,
                    vx: (Math.random() - 0.5) * 2,
                    vy: Math.random() * -1 - 1,
                    vz: (Math.random() - 0.5) * 0.5,
                    opacity: 1,
                    size: 10 / z,
                    life: Math.random() * 20 + 20
                });
            }
            
            function updateParticles() {
                for (let i = 0; i < particles.length; i++) {
                    const p = particles[i];
                    p.x += p.vx;
                    p.y += p.vy;
                    p.z += p.vz;
                    p.life--;
                    p.opacity = p.life / 40;
                    
                    if (p.life <= 0) {
                        particles.splice(i, 1);
                        i--;
                    }
                }
            }
            
            // Draw the matrix rain
            function draw() {
                // Clear canvas with semi-transparent black for trail effect
                ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
                ctx.fillRect(0, 0, width, height);
                
                // Update particles
                updateParticles();
                
                // Draw particles
                for (let i = 0; i < particles.length; i++) {
                    const p = particles[i];
                    const size = p.size;
                    
                    ctx.save();
                    ctx.globalAlpha = p.opacity;
                    ctx.fillStyle = '#0f9';
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#0f9';
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }
                
                // Draw matrix drops
                for (let i = 0; i < drops.length; i++) {
                    const drop = drops[i];
                    
                    // Calculate perspective scaling based on z depth
                    const scale = 1 / drop.z;
                    const scaledSpeed = drop.speed * (config.speed / 3);
                    const fontSize = Math.max(14 * scale, 8);
                    
                    // Update drop position
                    drop.y += scaledSpeed;
                    
                    // Change characters randomly
                    for (let j = 0; j < drop.characters.length; j++) {
                        if (Math.random() > 0.96) {
                            drop.characters[j].char = matrixChars.charAt(
                                Math.floor(Math.random() * matrixChars.length)
                            );
                        }
                        
                        drop.characters[j].changeTime--;
                        if (drop.characters[j].changeTime <= 0) {
                            drop.characters[j].char = matrixChars.charAt(
                                Math.floor(Math.random() * matrixChars.length)
                            );
                            drop.characters[j].changeTime = Math.floor(Math.random() * 30) + 10;
                        }
                    }
                    
                    // Draw characters in the drop
                    for (let j = 0; j < drop.characters.length; j++) {
                        const charObj = drop.characters[j];
                        const y = drop.y - j * fontSize * 1.5;
                        
                        // Skip if out of screen
                        if (y < 0 || y > height) continue;
                        
                        // Calculate brightness based on position in the drop
                        let brightness = 1;
                        if (j === 0) {
                            brightness = 1; // First character is brightest
                            
                            // Create particles at the head of the drop randomly
                            if (Math.random() > 0.98) {
                                createParticle(drop.x, y, drop.z);
                            }
                        } else {
                            brightness = 1 - (j / drop.length);
                        }
                        
                        // Draw character with glow effect
                        ctx.save();
                        
                        // Set font size with perspective
                        ctx.font = `${fontSize}px monospace`;
                        
                        // Head character with stronger glow
                        if (j === 0) {
                            ctx.fillStyle = '#fff';
                            ctx.shadowColor = '#0f9';
                            ctx.shadowBlur = 20;
                            ctx.fillText(charObj.char, drop.x, y);
                            
                            // Double glow effect
                            ctx.shadowColor = '#fff';
                            ctx.shadowBlur = 5;
                            ctx.fillText(charObj.char, drop.x, y);
                        } else {
                            const alpha = brightness * charObj.opacity;
                            ctx.fillStyle = `rgba(0, 255, 153, ${alpha})`;
                            ctx.shadowColor = '#0f9';
                            ctx.shadowBlur = 10 * brightness;
                            ctx.fillText(charObj.char, drop.x, y);
                        }
                        
                        ctx.restore();
                    }
                    
                    // Reset if drop is off screen
                    if (drop.y - fontSize * drop.length > height) {
                        drop.y = Math.random() * height * -1 - 100;
                        drop.x = Math.random() * width;
                        drop.speed = Math.random() * 2 + 1;
                    }
                }
                
                // Apply volumetric fog effect
                ctx.fillStyle = 'rgba(0, 15, 8, 0.03)';
                ctx.fillRect(0, 0, width, height);
                
                requestAnimationFrame(draw);
            }
            
            // Update configuration based on controls
            function updateConfig() {
                config.depth = parseInt(depthControl.value);
                config.speed = parseInt(speedControl.value);
                config.density = parseInt(densityControl.value);
            }
            
            // Event listeners
            depthControl.addEventListener('change', function() {
                updateConfig();
                initDrops();
            });
            
            speedControl.addEventListener('change', updateConfig);
            
            densityControl.addEventListener('change', function() {
                updateConfig();
                initDrops();
            });
            
            resetBtn.addEventListener('click', function() {
                depthControl.value = 5;
                speedControl.value = 5;
                densityControl.value = 15;
                updateConfig();
                initDrops();
            });
            
            window.addEventListener('resize', resizeCanvas);
            
            // Initialize
            updateConfig();
            resizeCanvas();
            draw();
        });
    </script>
</body>
</html>
